generator client {
  provider = "prisma-client-py"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}


// ! Users       =============================================================================

model Users {
  id                String         @id @default(auto()) @map("_id") @db.ObjectId

  firstName         String
  lastName          String
  email             String          @unique
  role              Roles
  avatar            String?
  password          String

  city              String
  state             String
  zipCode           Int

  // m-to-n
  childIDs String[]   @db.ObjectId
  children  Children[]   @relation(fields: [childIDs], references: [id])

  eventIDs String[] @db.ObjectId
  events Events[] @relation(fields: [eventIDs], references: [id])

  createdAt         DateTime
  updatedAt         DateTime

  // One-to-m
  notifications     Notifications[]
  reviews           Reviews[]
}

enum Roles {
  parent
  admin
  instructor
  volunteer
}


model Children {
  id                    String  @id @default(auto()) @map("_id") @db.ObjectId
  firstName             String
  lastName              String
  homeschool            Boolean
  birthday              DateTime
  notes                 String?
  waiver                Boolean

  parentIDs String[] @db.ObjectId
  parents   Users[]   @relation(fields: [parentIDs], references: [id])

  eventIDs String[] @db.ObjectId
  events Events[] @relation(fields: [eventIDs], references: [id])

  createdAt         DateTime @default(now())
  updatedAt         DateTime? @updatedAt
}

// ! Activities     =============================================================================

model Activities {
  id            String      @id @default(auto()) @map("_id") @db.ObjectId
  name          String      @unique
  description   String

  events        Events[]
}

// ! Events         =============================================================================

model Events {
    id          String      @id @default(auto()) @map("_id") @db.ObjectId

    name          String      @unique
    description   String
    date          DateTime
    image         String
    participants  Int @default(0)
    limit         Int @default(10)
    
    city          String
    state         String
    address       String
    zipCode       Int
    latitude      Float
    longitude     Float

    childIDs  String[] @db.ObjectId
    children  Children[] @relation(fields: [childIDs], references: [id])

    userIDs   String[] @db.ObjectId
    users     Users[] @relation(fields: [userIDs], references: [id])

    activity    Activities   @relation(fields: [activityId], references: [id])
    activityId  String      @db.ObjectId

    reviews     Reviews[]

    jobs        Jobs[]

    createdAt         DateTime @default(now())
    updatedAt         DateTime? @default(now())
}

// ! reviews        =============================================================================

model Reviews {
    id          String      @id @default(auto()) @map("_id") @db.ObjectId
    rating      Int
    description String

    event       Events       @relation(fields: eventId, references: [id])
    eventId     String      @db.ObjectId

    parent      Users        @relation(fields: [parentId], references: [id])
    parentId    String      @db.ObjectId

    createdAt         DateTime @default(now())
    updatedAt         DateTime? @updatedAt
}

// ! Notifications   =============================================================================

model Notifications {
  id                    String  @id @default(auto()) @map("_id") @db.ObjectId
  title                 String
  description           String
  isRead                Boolean @default(false)
  time                  DateTime
  // icon                  String?
  createdAt             DateTime @default(now())

  user   Users   @relation(fields: [userId], references: [id])
  userId String @db.ObjectId
}

// ! jobs           =============================================================================

// ? Jobs table allows us to work with scheduling logic for notifications
enum ReminderTypes {
  email
  sms
}

enum ReminderStatus {
  pending
  sent
  undeliverable
}

enum JobTypes {
  reminder
  cancellation
}

model Jobs{
   id                String      @id @default(auto()) @map("_id") @db.ObjectId
   runAt             DateTime
   reminderType      ReminderTypes
   status            ReminderStatus
   jobType           JobTypes
   sentAt            DateTime?
   errorMessage      String?          // Log issues if notification is undeliverable

   event             Events? @relation(fields:[eventId], references: [id], onDelete: Cascade)
   eventId           String @db.ObjectId
}
